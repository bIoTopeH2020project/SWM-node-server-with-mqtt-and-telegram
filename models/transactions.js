

var mongoose = require('mongoose'),
Schema = mongoose.Schema;

var TransactionSchema = new Schema({
  
  sgb : { type: Schema.ObjectId, ref: 'SGB' },
  user_account : { type: String, required : true }, // account string of the user using the sgb
  qr_code : { type: String, required : true }, // this qr is generated when user selects to throw waste from telegram app
  waste_type : {
    type: String,
    enum: ["ORGANIC", "PLASTIC", "GLASS" , "METAL"],
    required : true
                }, // Only one of these options are possible for owner_type
                waste_weight : { type: Number },
  transaction_cost : { type: Number, default : null} // in ETH, the gasUsed attribute of block is to be queried to get this value
});


// these are more like model methods. forExample: <SGB_Detail_Schema_object>.date returns the current timestamp
TransactionSchema.virtual('timestamp')
.get(function(){
  return this._id.getTimestamp();
});

//total_cost is the total price a SGB owner has to incur. It includes the cost of investment per transaction plus the gasPrice to execute the transaction
//If blockchain is to be used as a storage, the gasPrice for transaction is going to increase significantly
TransactionSchema.virtual('total_cost').get(function(){
  if(this.transaction_cost != null)
    return this.sgb.fixed_unit_cost + this.transaction_cost;
  return null;
});

//checks if a transaction is complete. Look below for desciprtion of a complete transaction
TransactionSchema.virtual('is_complete').get(function(){
  return this.transaction_cost;
});




module.exports = mongoose.model('Transaction', TransactionSchema);

// Steps in which this collection is updated:
/*
    1. User sends request to nodejs server to throw waste. Data contains : Account, waste type
    2. NodeJS uses Web3 RPC to check the balance in user account
    3. If sufficient balance: 
        then: 
              1. A QR code with a random string is generated by the server
              2. An insert query is fired into this collection with user_account,qr_code, waste_type
    4. At this point, the transaction is not complete. Only half of the process is completed.
    5. Now when user introduces the QR to a SGB, the SGB decodes it and sends a mqtt request to the nodejs server
    6. the nodejs server checks the authenticity of the QR code in the transactions collection.
    7. If authenticate, the server sends a MQTT request to SGB telling the user is authetic
    8. After the lid is closed, (this means the waste is put in the box, more like a JS event ), the SGB sends SGB_id, waste_weight, qr_code
    9. The current_state of SGB collection is updated (this.current_state += current_state, meaning new waste is added in SGB )
       and the SGB object and waste_weight is updated in the transaction table using the qr_code to identify the appropriate transaction
    10. The funds are transferred from user_account to owner_account using a callback query, which also requests for gasPrice 
        (transaction_id of transaction collection is also sent as parameter) i.e. the gas consumed by this block in ethereum blockchain
    11. This gasPrice is updated in the transaction table using the transaction_id when the callback receives a value from the ethereum blockchain

    NOTE : A virtual  'is_complete' is defined for this model which returns the state of transaction. While querying, this field should be checked always
*/